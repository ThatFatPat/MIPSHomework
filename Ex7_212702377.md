## Question 1
### Question 1.a
```asm
$v0 = 2
```
This program loops over two given arrays. It will stop on the first iteration the arrays differ, and count only the iterations in which they are similar.

Therefore in this case `$v0` will be `2` as the arrays differ on the **3rd** element.

### Question 1.b
The final result will be:
```python
A = [1, 8, 25, 18]
B = [5, 7, 9, 18]
```
This program performs the following operation on the **ith** (0-based) iteration
```python
A[i+1] = A[i+2] + B[i]
```
Since we know that before entering the loop `$a2 = 3` and `$t0 = 1`, as well as the fact that `$t0` is the loop counter,
if the loop stops when `$a2 == $t0` then we'll perform **2** iterations.
And so, we get the solution described above.

### Question 1.c
The simplest way to solve the following exercise is to first *"compile"* it into readable python code:
```python
s1 = 0
s2 = 1
while s2 < 10:
    s1 += s2//2
    if s1 == s2:
        s1 += s2
    s2 += 1
s3 = s2 * s1
```
After we've constructed the code, we can easily follow 9 iterations and get our results:
```asm
$s1 = 24
$s2 = 10
$s3 = 240
```

## Question 2
```asm
my_func: 
    slt $t0, $a0, $a1
    addi $t1, $zero, 1 # Solve a stall by initializing i here
    beq $t0, $zero, else
    # NOP Here!
        add $s2, $a0, $a1
        j loop
        # NOP Here!
        
    else: 
        add $a0, $a0, $a1
        sub $s2, $a1, $a0
        
    loop: 
        slti t2, $t1, 11
        beq $t2, $zero, end
        # NOP Here!
            add $s0, $s0, $a0
            add $a0, $a0, $a0
            addi $t1, $t1, 1
        j loop
        # NOP Here!
        
    end: 
        sw $s0, 16($s3)
        jr $ra
        addi $v0, $a0, 0 # Branch delay slot
```
There are a lot of additional optimizations to be made, and if we compared this to the output from Godbolt with -O3 we would get code that's completely unrecognizable, but I wanted to keep this readable. (As well as not optimize out `c`)
The `# NOP Here!` lines indicate a spot where a branch delay slot would be necessary if this were running on an actual processor.

## Question 3
### Question 3.a
```asm
sum_it_up:
    addi $t0, $zero, 0
    addi $t1, $zero, 0
  
    loop:
        lw $t3, 0($a0)
        sne $t4, $t3, $zero
        slt $t5, $t3, 0x400 # We set here to avoid a delay later, 
                            # and to prevent an idle hiccup between the line above and below.
        beq $t4, $zero, end
          add $a0, $a0, 4
          beq $t5, $zero, loop
              addi $t1, $t1, 1 # We use the branch delay slot to always increment $t1
              add $t0, $t0, $t3
              j loop
    end: 
        addi $v0, $t0, 0
        jr $ra
        nop
```

### Question 3.b
```asm
```
